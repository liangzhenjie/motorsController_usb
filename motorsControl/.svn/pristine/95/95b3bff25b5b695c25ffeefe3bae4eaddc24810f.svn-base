#include "mediator.h"
#include "communication.h"
#include "autorecoginze.h"
#include "proxyparser.h"
#include "dataUtil.h"
#include "innfosproxy.h"
#include <QDebug>
#include "motordata.h"

Mediator * Mediator::m_pInstance = nullptr;
Mediator *Mediator::getInstance()
{
    if(!m_pInstance)
    {
        m_pInstance = new Mediator;
    }

    return m_pInstance;
}

void Mediator::destroyAllStaticObjects()
{
    //MotorMgr::autoDestroy();
    AutoRecoginze::autoDestroy();
    Communication::autoDestroy();
    DataUtil::autoDestroy();
    ProxyParser::autoDestroy();

    if(m_pInstance)
        delete m_pInstance;
    m_pInstance = nullptr;

}

void Mediator::autoRecognize(recognizeCallback finishedCallback, bool bRetry)
{
    m_recognizeCallback = finishedCallback;
#ifdef TEST_DEBUG
    connect(Communication::getInstance(),&Communication::request,ProxyWatcher::getInstance(),&ProxyWatcher::addSendItem);
#endif
    AutoRecoginze::getInstance()->startRecognize(bRetry);
}

void Mediator::SendRequest(const QByteArray &buf)
{
    quint8 nId = buf.at(1);
    Communication::getInstance()->sendData(nId,buf);
}

void Mediator::Handshake(quint32 nDeviceId, bool bSuccess)
{
    motorDataMgrInstance->responseHeart(nDeviceId,bSuccess);
}

void Mediator::SetCurParam(const int nDeviceID, const QVariant value, const int nProxyId)
{
    motorDataMgrInstance->setMotorDataAttrByProxy(nDeviceID,nProxyId,value);//data from device
}

void Mediator::SetSucceed(const quint8 nDeviceId, const int nParam)
{

    switch (nParam) {
    case D_SET_DEVICE_ID:
        motorDataMgrInstance->activeMotorModeSuccessfully(nDeviceId);
        break;
    case D_SET_MODE:
        motorDataMgrInstance->activeMotorModeSuccessfully(nDeviceId);
        break;
    default:
        break;
    }
}

void Mediator::SetFailed(const int nParam)
{
    Q_UNUSED(nParam);
}

void Mediator::revertSwitch(const quint8 nDeviceId)
{
    Q_UNUSED(nDeviceId);
}

void Mediator::reciveMotorInfo(quint8 communicateUnitId, const quint32 nDeviceMac, const quint8 nDeviceId)
{
    AutoRecoginze::getInstance()->addMototInfo(nDeviceId,nDeviceMac);
    Communication::getInstance()->addRelateIdToUnit(communicateUnitId,nDeviceId);
}

void Mediator::receiveNoDataProxy(const int nDeviceID)
{
    switch (nDeviceID) {
    case D_CHART_DATA_STATR:
        emit startNewPeriodChart();
        break;
    default:
        break;
    }
}

void Mediator::saveDataToDevice(const quint8 nDeviceId)
{
    InnfosProxy::SendProxy(nDeviceId,D_SAVE_PARAM);
}


void Mediator::switchCalibrationVel(quint8 nDeviceId, quint8 nValue)
{
    InnfosProxy::SendProxy(nDeviceId,D_SWITCH_CALIBRATION_VEL,nValue);
}

void Mediator::switchCalibration(quint8 nDeviceId, quint8 nValue)
{
    InnfosProxy::SendProxy(nDeviceId,D_SWITCH_CALIBRATION,nValue);
}

void Mediator::startCalibration(quint8 nDeviceId)
{
    InnfosProxy::SendProxy(nDeviceId,D_START_CALIBRATION);
}


//void Mediator::saveDataToDevice()
//{
//    MotorData * pMotor = MotorMgr::getInstance()->getMotorByDeviceId(nDeviceId);
//    if(pMotor)
//        InnfosProxy::SendProxy(pMotor->deviceId(),D_SAVE_PARAM);
//    QVector<MotorData *> selMotors = MotorMgr::getInstance()->allSelectedMotors();
//    foreach (MotorData * pMotor, selMotors)
//    {
//       InnfosProxy::SendProxy(pMotor->deviceId(),D_SAVE_PARAM);
//    }
//}


void Mediator::clearHoming(quint8 nDeviceId)
{
    InnfosProxy::SendProxy(nDeviceId,D_CLEAR_HOMING);
}

void Mediator::clearHomingSuccessfully(quint8 nDeviceId)
{
    motorDataMgrInstance->setMotorDataAttr(nDeviceId,MotorData::POS_MAX_POS,0,false);
    motorDataMgrInstance->setMotorDataAttr(nDeviceId,MotorData::POS_MIN_POS,0,false);
    motorDataMgrInstance->setMotorDataAttr(nDeviceId,MotorData::POS_HOMING,0,false);
}

void Mediator::setHomingOperation(quint8 nDeviceId,quint8 nId)
{
    InnfosProxy::SendProxy(nDeviceId,D_SET_HOMING_OPERATION,nId);
}

void Mediator::playAction(quint32 nMac, MotorData::Motor_Mode mode, qreal value)
{
    motorDataMgrInstance->changDemand(nMac,mode,value);
}


void Mediator::openChannel(quint8 nDeviceId,const int nChannelId)
{
    int nProxyId[UserDefine::channel_cnt] = {D_CHANNEL1_OPEN,D_CHANNEL2_OPEN,D_CHANNEL3_OPEN,D_CHANNEL4_OPEN};
    InnfosProxy::SendProxy(nDeviceId,nProxyId[nChannelId]);
}

void Mediator::closeChannel(quint8 nDeviceId,const int nChannelId)
{
    int nProxyId[UserDefine::channel_cnt] = {D_CHANNEL1_CLOSE,D_CHANNEL2_CLOSE,D_CHANNEL3_CLOSE,D_CHANNEL4_CLOSE};
    InnfosProxy::SendProxy(nDeviceId,nProxyId[nChannelId]);
}

void Mediator::setLeftLimit(quint8 nDeviceId)
{
    InnfosProxy::SendProxy(nDeviceId,D_SET_HOMING_MIN);
}

void Mediator::setRightLimit(quint8 nDeviceId)
{
    InnfosProxy::SendProxy(nDeviceId,D_SET_HOMING_MAX);
}

int Mediator::getConnectStatus() const
{
    return AutoRecoginze::getInstance()->GetConnectStatus();
}

void Mediator::recognizeFinished(QMap<quint8, quint32> motorsInfo)
{
    motorDataMgrInstance->AddMotorsData(motorsInfo);//add to logic manager
    Communication::getInstance()->removeUnAvailablePorts();
    if(m_recognizeCallback)
        m_recognizeCallback();
}

void Mediator::loadDataFromFile()
{
    //to do
}

void Mediator::saveDataToFile()
{
    //to do
}

void Mediator::setTriggerMode(quint8 nDeviceId, quint8 mode)
{
    InnfosProxy::SendProxy(nDeviceId,D_SET_CUR_TRIGGER_MODE,mode);
}

void Mediator::switchChartData(quint8 nDeviceId, bool bOn)
{
    quint8 nProxyId = bOn?D_CHART_OPEN:D_CHART_CLOSE;
    InnfosProxy::SendProxy(nDeviceId,nProxyId);
}


void Mediator::checkServosStatus()
{
    //MotorMgr::getInstance()->CheckServosSwitch(); //to do
}

void Mediator::response(quint8 nUnitId, const QByteArray buf)
{
    ProxyParser::getInstance()->parse(nUnitId,buf);

}

void Mediator::reconnectDevice(quint8 nDeviceId)
{
    motorDataMgrInstance->setMotorDataAttr(nDeviceId,MotorData::ONLINE_STATUS,UserDefine::Status_Online);
}

Mediator::Mediator(QObject *parent):
    QObject(parent)
{
    connect(Communication::getInstance(),&Communication::response,this,&Mediator::response);
}


