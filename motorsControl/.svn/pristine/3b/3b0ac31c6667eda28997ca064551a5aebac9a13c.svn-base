#include "motordata.h"
#include "mediator.h"
#include "innfosproxy.h"
#include "dataUtil.h"
#include <QDebug>

const int nMaxErrorCnt = 30;
MotorData::MotorData(const quint8 nDeviceId, const quint32 nDeviceMac, QObject *parent) :
    QObject(parent),
    m_requestModeId(Mode_None),
    m_nHeartFailCnt(0),
    m_oldDeviceId(-1),
    m_nAutoRequestInterval(1000)
{
    initData();
    setValue(DEVICE_ID,nDeviceId);
    setValue(MAC_ID,nDeviceMac);
    m_pHeartTimer = new QTimer(this);
    connect(m_pHeartTimer,&QTimer::timeout,[=]{
        if(!isOnline())
        {
            setValue(ONLINE_STATUS,UserDefine::Status_Offline);
            m_pHeartTimer->stop();
            m_pValueTimer->stop();
        }
        else
        {
            InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_HANDSHAKE);
            ++ m_nHeartFailCnt;
        }
    });
    m_pValueTimer = new QTimer(this);
    connect(m_pValueTimer,&QTimer::timeout,this,&MotorData::requestActualValue);
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_READ_VERSION);
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_READ_MOTORS_SWITCH);
}

MotorData::~MotorData()
{

}

void MotorData::changeDeviceIdSuccessfully()
{
    m_oldDeviceId = -1;
}

bool MotorData::deviceIdIsAvailable() const
{
    return m_oldDeviceId < 0;
}


void MotorData::changeDemand(qreal value)
{
    switch (getValue(MODE_ID).toUInt()) {
    case Mode_Cur:

        setValueByUser(CUR_IQ_SET,value);
        break;
    case Mode_Vel:
    case Mode_Profile_Vel:

        setValueByUser(VEL_SET,value);
        break;
    case Mode_Pos:
    case Mode_Profile_Pos:

        setValueByUser(POS_SET,value);
        break;
    default:
        break;
    }
}

void MotorData::switchAutoRequestActual(bool bStart)
{
    if(bStart)
    {
        m_pValueTimer->start();
        m_pHeartTimer->start();
    }
    else
    {
        m_pValueTimer->stop();
        m_pHeartTimer->stop();
    }
}

void MotorData::setAutoRequestInterval(quint32 mSec)
{

}

void MotorData::setValue(int nDataId, QVariant value, bool bEmitSignal)
{
    if(DATA_CNT > nDataId)
    {
        m_motorData[nDataId] = value;
        if(bEmitSignal)
            //emit mediator->deviceDataChange(getValue(DEVICE_ID).toUInt(),(Motor_Data_Id)nDataId,value);
            motorDataMgrInstance->dataChanged(getValue(DEVICE_ID).toUInt(),(Motor_Data_Id)nDataId,value);
    }
}

void MotorData::initData()
{
    for(int i=CUR_IQ_SET;i<DATA_CNT;++i)
        m_motorData[i] = 0;
    setValue(CURRENT_SCALE,curScale);
    setValue(VELOCITY_SCALE,velScale);
    setValue(ERROR_ID,UserDefine::MOTOR_NO_ERROR);
}

void MotorData::activeMode(const int nMode)
{
    if(nMode < Mode_None || nMode > Mode_Homing/* || nMode==m_modeId*/)
        return;
    m_requestModeId = nMode;
    //active mode
    quint8 uMode = m_requestModeId;
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_SET_MODE,uMode);

}

void MotorData::activeModeSuccessfully()
{
    setValue(MODE_ID,m_requestModeId);
    switch (getValue(MODE_ID).toUInt()) {
    case Mode_Cur:
        setValueByUser(CUR_IQ_SET,0,false);//reset demand
        break;
    case Mode_Vel:
        setValueByUser(VEL_SET,0,false);//reset demand
        break;
    case Mode_Pos:
        break;
    case Mode_Profile_Pos:
        break;
    case Mode_Profile_Vel:
        //setValueByUser(VEL_SET,0,false);//reset demand
        break;
    default:
        break;
    }

}

void MotorData::requestActualValue()
{
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_READ_CUR_CURRENT);
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_READ_CUR_VELOCITY);
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_READ_CUR_POSITION);
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_READ_VOLTAGE);
}

void MotorData::saveData()
{
//    QFileDialog dialog(nullptr,tr("Save as"),QDir::currentPath());
//    dialog.setFileMode(QFileDialog::AnyFile);
//    dialog.setAcceptMode(QFileDialog::AcceptSave);
//    dialog.setNameFilter(tr("Innfos(*.innfos)"));
//    if(dialog.exec() == QDialog::Accepted)
//    {
//        QString path = dialog.selectedFiles().first();
//        if(path.size() > 0)
//        {
//            saveDataToFile(path);
//        }

//    }
}

void MotorData::loadData()
{
//    QFileDialog dialog(nullptr,tr("Load"),QDir::currentPath());
//    dialog.setFileMode(QFileDialog::ExistingFile);
//    dialog.setNameFilter(tr("Innfos(*.innfos)"));
//    if(dialog.exec() == QDialog::Accepted)
//    {
//        QString path = dialog.selectedFiles().first();
//        if(path.size() > 0)
//        {
//            readDataFromFile(path);
//        }

//    }
}

void MotorData::reconnect()
{
    m_nHeartFailCnt = 0;
    if(m_pHeartTimer)
    {
        m_pHeartTimer->start();
    }
    if(m_pValueTimer)
    {
        m_pValueTimer->start();
    }
}

void MotorData::changeDeviceId(quint8 nNewDeviceId)
{
    m_oldDeviceId = getValue(DEVICE_ID).toUInt();
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),getValue(MAC_ID).toUInt(),D_SET_DEVICE_ID,nNewDeviceId);
    setValue(DEVICE_ID,nNewDeviceId);
}

MotorData::Motor_Mode MotorData::currentMode() const
{
    return (Motor_Mode)(getValue(MODE_ID).toInt());
}

void MotorData::saveDataToFile(QString fileName)//todo
{
    QFile file(fileName);
    if(!file.open(QFile::WriteOnly | QFile::Text | QFile::Truncate))
    {
        qDebug() << tr("Cannot write file %1 %2").arg(fileName).arg(file.errorString());
        return;
    }

//    QJsonArray arr;
////    for(int i=0;i<DATA_CNT;++i)
////    {
////        QJsonObject attr;
////        attr[tr("Attr%1").arg(i)] = m_motorData[i];
////        arr.append(attr);
////    }
//    QJsonDocument saveDoc(arr);
//    file.write(saveDoc.toJson());
    file.close();
}

void MotorData::readDataFromFile(QString fileName)
{
    QFile file(fileName);
    if(file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        QXmlStreamReader reader(&file);
        while(!reader.atEnd())
        {
            QXmlStreamReader::TokenType nType = reader.readNext();
            switch (nType)
            {
            case QXmlStreamReader::StartDocument:

                break;
            case QXmlStreamReader::StartElement:
            {
                QString strElementName = reader.name().toString();
                if(strElementName == "ServoData")
                {
                    QXmlStreamAttributes attributes = reader.attributes();
                    if(attributes.hasAttribute("Version") && attributes.value("Version").toString() == "1.0")
                    {
                        readParams(&reader);
                    }
                }
            }
                break;
            default:
                break;
            }
        }
        if(reader.hasError())
        {
            qDebug() << tr("Errorinfo:%1 line:%2 column:%3 character offset:%4").arg(reader.errorString()).arg(reader.lineNumber()).arg(reader.columnNumber()).arg(reader.characterOffset());
        }
        file.close();
    }


}

void MotorData::readParams(QXmlStreamReader *reader)
{
    while (!reader->atEnd()) {
        reader->readNext();
        if(reader->isStartElement())
        {
            QString strElementName = reader->name().toString();
            int nIdx = strElementName.indexOf("Attr");
            if(nIdx >=0)
            {
                int nAttrId = strElementName.right(strElementName.size()-4).toInt();
                if(nAttrId>=0 && nAttrId<DATA_CNT)
                {
                    qreal readValue = reader->readElementText().toDouble();
                    if(m_motorData[nAttrId] != readValue)
                    {
                        m_motorData[nAttrId] = readValue;
                        //emit dataChange((Motor_Data_Id)nAttrId);to do
                    }

                }
            }
        }
    }
}




quint8 MotorData::deviceId() const
{
//    if(m_oldDeviceId >=0)
//        return m_oldDeviceId;
    return getValue(DEVICE_ID).toUInt();
}

quint32 MotorData::deviceMac() const
{
    return getValue(MAC_ID).toUInt();
}

void MotorData::setValueByProxy(const int nProxyId, QVariant value)
{
    //responseHeart(true);
    if(!isOnline())
        responseHeart(true);
    else
        m_nHeartFailCnt = 0;

    switch (nProxyId) {
    case D_SET_MODE:
        setValue(MODE_ID,m_requestModeId);
        break;
    case D_ERROR:
        setValue(ERROR_ID,value);
        m_errorHistory.append(value.toInt());
        break;
    case D_READ_MOTORS_SWITCH:
        if(value.toInt() == UserDefine::MOTOR_SWITCH_ON && m_motorData[MOTOR_SWITCH].toInt()==UserDefine::MOTOR_SWITCH_OFF)
        {
            requestAllValue();
        }
        setValue(MOTOR_SWITCH,value.toInt());

        break;
    case D_SET_SWITCH_MOTORS:
        if(value.toInt() == UserDefine::MOTOR_SWITCH_ON)
        {
            requestAllValue();
        }
        setValue(MOTOR_SWITCH,value.toInt());

        break;
    default:
        Directives proxy = (Directives)nProxyId;
        Motor_Data_Id id = DataUtil::convertToMotorDataId(proxy);
        if(id != DIRECTIVES_INVALID)
        {
            setValue(id,value);
        }    
        break;
    }
}

void MotorData::requestAllValue()
{
//    activeMode(Mode_Cur);
//    for (int i=D_READ_CUR_CURRENT;i<=D_READ_CUR_POSITION;++i)
//    {
//        InnfosProxy::SendProxy(m_deviceId,i);
//    }

    for (int i=D_READ_CUR_P;i<=D_READ_PROFILE_POS_DEC;++i)
    {
        InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),i);
    }

    for (int i=D_READ_PROFILE_VEL_MAX_SPEED;i<=D_READ_PROFILE_VEL_DEC;++i)
    {
        InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),i);
    }

    for (int i=D_READ_CURRENT_PID_MIN;i<=D_READ_POSITION_PID_MAX;++i)
    {
        InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),i);
    }

    for (int i=D_READ_CHART_THRESHOLD;i<=D_READ_CHART_FREQUENCY;++i)
    {
        InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),i);
    }
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_READ_VOLTAGE);
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_READ_CURRENT_SCALE);

    for (int i=D_READ_MAX_POS;i<=D_READ_MIN_POS;++i)
    {
        InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),i);
    }

    for (int i=D_READ_POS_OFFSET;i<=D_READ_HOMING_LIMIT;++i)
    {
        InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),i);
    }
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_READ_VERSION);
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_READ_HOMING_CUR_MIN);
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_READ_HOMING_CUR_MAX);

    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_READ_FILTER_C_STATUS);
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_READ_FILTER_C_VALUE);
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_READ_FILTER_V_STATUS);
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_READ_FILTER_V_VALUE);
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_READ_FILTER_P_STATUS);
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_READ_FILTER_P_VALUE);
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_READ_INERTIA);
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_READ_LOCK_ENERGY);
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_READ_TEMP_MOTOR);
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_READ_TEMP_INVERTER);
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_READ_TEMP_PROTECT);
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_READ_TEMP_RECOVERY);
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_READ_CALIBRATION_SWITCH);
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_READ_CALIBRATION_ANGLE);
    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_READ_MOTORS_SWITCH);
    //InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_ERROR);
#ifndef NO_HEART_BEAT
    m_pHeartTimer->start(1000);
    m_pValueTimer->start(m_nAutoRequestInterval);
#endif
}

QVariant MotorData::getValue(MotorData::Motor_Data_Id nDataId) const
{
    Q_ASSERT(nDataId < DATA_CNT);
    if(nDataId < DATA_CNT)
    {
        return m_motorData[nDataId];
    }
    return -1;
}

void MotorData::setValueByUser(MotorData::Motor_Data_Id nDataId, QVariant value, bool bSendProxy)
{
    if (/*getValue(nDataId) != value*/true)
    {
        Directives pId = DataUtil::convertToSetProxyId(nDataId);
        //m_motorData[nDataId] = value;
        setValue(nDataId,value);
        if(pId != DIRECTIVES_INVALID)
        {
            //
            if(bSendProxy)
            {
                switch (pId) {
                case D_SET_CHART_FREQUENCY:// these values are qint16
                {
                    qint16 nValue = value.toInt();
                    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),pId,nValue);
                }
                    break;
                case D_SET_LOCK_ENERGY://
                {
                    qint32 nValue = value.toInt()*75.225;
                    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),pId,nValue);
                }
                    break;
                case D_SET_FILTER_C_VALUE:
                case D_SET_FILTER_V_VALUE:
                case D_SET_FILTER_P_VALUE:
                case D_SET_TEMP_PROTECT:
                case D_SET_TEMP_RECOVERY:
                {
                    qint16 nValue = value.toInt()*(1<<8);
                    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),pId,nValue);
                }
                    break;
                case D_SET_HOMING_LIMIT:
                case D_SET_FILTER_C_STATUS:
                case D_SET_FILTER_V_STATUS:
                case D_SET_FILTER_P_STATUS:
                case D_SWITCH_CALIBRATION:
                case D_SET_SWITCH_MOTORS:
                {
                    quint8 invertValue = value.toInt();
                    InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),pId,invertValue);
                }
                    break;
                case D_ERROR:
                    if(value.toInt() == UserDefine::MOTOR_NO_ERROR)//clear error
                    {
                        InnfosProxy::SendProxy(getValue(DEVICE_ID).toUInt(),D_CLEAR_ERROR);
                    }
                    break;
                default:
                    InnfosProxy::SendQrealProxy(getValue(DEVICE_ID).toUInt(),pId,value.toDouble());
                    break;
                }
            }
        }
    }
}

void MotorData::responseHeart(bool bSuccess)
{
    if(bSuccess && isOnline())//判断掉线以后，如果接收到心跳，不管他
    {
        m_nHeartFailCnt = 0;
        if(getValue(ONLINE_STATUS).toInt() == UserDefine::Status_Offline)//这种情况只有断线重连才会判断成功，重连后m_nHeartFailCnt，但是电机数据在线状态还是断线
            setValue(ONLINE_STATUS,UserDefine::Status_Online);//
    }

}

bool MotorData::isOnline() const
{
#ifdef MY_DEBUG
    return true;
#endif
    return m_nHeartFailCnt < 5;
}

//data manager

MotorDataMgr * MotorDataMgr::m_pMgr = nullptr;

MotorDataMgr* MotorDataMgr::getInstance()
{
    if(m_pMgr == nullptr)
        m_pMgr = new MotorDataMgr();
    return m_pMgr;
}

MotorDataMgr::MotorDataMgr()
{

}

MotorDataMgr::~MotorDataMgr()
{

}

QVariant MotorDataMgr::getMotorDataAttrValue(const quint8 nDeviceId, const MotorData::Motor_Data_Id attrId) const
{
    MotorData * pData = getMotorDataById(nDeviceId);
    if(pData)
        return pData->getValue(attrId);
    qDebug()<< tr("getValue error DeviceId%1 AttrId%2").arg(nDeviceId).arg(attrId);
    return QVariant();//null
}

qreal MotorDataMgr::getMotorDataAttrValueAsDouble(const quint8 nDeviceId, const MotorData::Motor_Data_Id attrId) const
{
    bool bOK = false;
    qreal ret = getMotorDataAttrValue(nDeviceId,attrId).toDouble(&bOK);
    if(bOK)
        return ret;
    qDebug()<< tr("getValue error DeviceId%1 AttrId%2").arg(nDeviceId).arg(attrId);
    return 0;
}

qint32 MotorDataMgr::getMotorDataAttrValueAsInt(const quint8 nDeviceId, const MotorData::Motor_Data_Id attrId) const
{
    bool bOK = false;
    qint32 ret = getMotorDataAttrValue(nDeviceId,attrId).toInt(&bOK);
    if(bOK)
        return ret;
    qDebug()<< tr("getValue error DeviceId%1 AttrId%2").arg(nDeviceId).arg(attrId);
    return 0;
}

void MotorDataMgr::setMotorDataAttr(const quint8 nDeviceId, const MotorData::Motor_Data_Id attrId, QVariant value, bool bSend)
{
    MotorData * pData = getMotorDataById(nDeviceId);
    if(pData)
    {
        pData->setValueByUser(attrId,value,bSend);
    }
    else
    {
        qDebug() << tr("Set Motor %1 Attri %2 value %3 failed! ").arg(nDeviceId).arg(attrId).arg(value.toDouble());
    }
}

void MotorDataMgr::setMotorDataAttrByProxy(const quint8 nDeviceId, int proxyId, QVariant value)
{
    MotorData * pData = getMotorDataById(nDeviceId);
    if(pData)
    {
        pData->setValueByProxy(proxyId,value.toDouble());
    }
    else
    {
        qDebug() << tr("Set Motor %1 Attri %2 value %3 failed! ").arg(nDeviceId).arg(proxyId).arg(value.toDouble());
    }
}

void MotorDataMgr::setMotorDataAttrInBatch(const QList<quint8> idList, const MotorData::Motor_Data_Id attrId, QVariant value, bool bSend)
{
    for(int i=0;i<idList.size();++i)
    {
        setMotorDataAttr(idList.at(i),attrId,value,bSend);
    }
}

void MotorDataMgr::AddMotorsData(QMap<quint8, quint32> dataMap)
{
    bool bUnique = checkIdUnique(dataMap);
    if(!bUnique)
    {
        handleUnuiqueError(dataMap);
        return;
    }
    QMapIterator<quint8, quint32> it(dataMap);
    while (it.hasNext())
    {
        it.next();
        MotorData * pData = new MotorData(it.key(),it.value(),this);
        m_allMotorDatas.append(pData);
        //pData->requestAllValue();
    }
}

QMap<quint8, quint32> MotorDataMgr::getMotorsMap() const
{
    QMap<quint8, quint32> dataMap;
    for(int i=0;i<m_allMotorDatas.size();++i)
    {
        MotorData * pData = m_allMotorDatas.at(i);
        dataMap.insert(pData->deviceId(),pData->deviceMac());
    }
    return dataMap;
}

QVector<qint16> MotorDataMgr::motorErrorHistory(const quint8 nDeviceId) const
{
    QVector<qint16> errorList;
    MotorData * pData = getMotorDataById(nDeviceId);
    if(pData)
        return pData->errorHistory();
    return errorList;
}

bool MotorDataMgr::deviceIdHasExist(quint8 nDeviceId)
{
    for(int i=0;i<m_allMotorDatas.size();++i)
    {
        MotorData * pData = m_allMotorDatas.at(i);
        if(pData->deviceId() == nDeviceId)
            return true;
    }
    return false;
}

void MotorDataMgr::activeMotorMode(const quint8 nDeviceId, const MotorData::Motor_Mode mode)
{
    MotorData * pData = getMotorDataById(nDeviceId);
    if(pData)
        pData->activeMode(mode);
}

void MotorDataMgr::activeMotorModeSuccessfully(const quint8 nDeviceId)
{
    MotorData * pData = getMotorDataById(nDeviceId);
    if(pData)
    {
        pData->activeModeSuccessfully();
        //emit dataChanged(nDeviceId,MotorData::MODE_ID,pData->getValue(MotorData::MODE_ID));
    }

}

void MotorDataMgr::activeMotorModeInBatch(const QList<quint8> idList, const MotorData::Motor_Mode mode)
{
    for(int i=0;i<idList.size();++i)
    {
        activeMotorMode(idList.at(i),mode);
    }
}

void MotorDataMgr::changeDeviceIdSuccessfully(const quint8 nDeviceId)
{
    MotorData * pData = getMotorDataById(nDeviceId);
    if(pData)
    {
        pData->changeDeviceIdSuccessfully();
    }
}

void MotorDataMgr::regainAllData(const quint8 nDeviceId)
{
    MotorData * pData = getMotorDataById(nDeviceId);
    if(pData)
        pData->requestAllValue();
}

void MotorDataMgr::regainData(const quint8 nDeviceId, MotorData::Motor_Data_Id attrId)
{
    MotorData * pData = getMotorDataById(nDeviceId);
    if(pData)
    {
        Directives proxyId = DataUtil::convertToReadProxyId(attrId);
        if(proxyId != DIRECTIVES_INVALID)
        {
            InnfosProxy::SendProxy(nDeviceId,proxyId);
        }
    }
}

void MotorDataMgr::responseHeart(const quint8 nDeviceId, bool bSuccessfully)
{
    MotorData * pData = getMotorDataById(nDeviceId);
    if(pData)
    {
        pData->responseHeart(bSuccessfully);
    }
}

void MotorDataMgr::changDemand(const quint32 nMacId,MotorData::Motor_Mode modeId, qreal value)
{
    MotorData * pData = getMotorDataByMac(nMacId);
    if(pData)
    {
        if(pData->getValue(MotorData::MODE_ID).toInt() != modeId)
        {
            pData->activeMode(modeId);
        }
        else
        {
            pData->changeDemand(value);
        }
    }
}

void MotorDataMgr::switchAutoRequestActual(const quint8 nDeviceId, bool bStart)
{
    MotorData * pData = getMotorDataById(nDeviceId);
    if(pData)
    {
        pData->switchAutoRequestActual(bStart);
    }
}

void MotorDataMgr::setAutoRequestInterval(const quint8 nDeviceId, quint32 mSec)
{
    MotorData * pData = getMotorDataById(nDeviceId);
    if(pData)
    {
        pData->setAutoRequestInterval(mSec);
    }
}

MotorData *MotorDataMgr::getMotorDataById(const quint8 nId) const
{
    for(int i=0;i<m_allMotorDatas.size();++i)
    {
        MotorData * pData = m_allMotorDatas.at(i);
        if(pData->deviceId() == nId)
            return pData;
    }
    return nullptr;
}

MotorData *MotorDataMgr::getMotorDataByMac(const quint32 nMac) const
{
    for(int i=0;i<m_allMotorDatas.size();++i)
    {
        MotorData * pData = m_allMotorDatas.at(i);
        if(pData->deviceMac() == nMac)
            return pData;
    }
    return nullptr;
}

bool MotorDataMgr::checkIdUnique(QMap<quint8, quint32> dataMap) const
{
    return dataMap.keys().size() == dataMap.uniqueKeys().size();
}

void MotorDataMgr::handleUnuiqueError(QMap<quint8, quint32> dataMap)
{
    QList<quint8> keys = dataMap.uniqueKeys();
    for(int i=0;i<keys.size();++i)
    {
        if(dataMap.values(keys.at(i)).size() > 1)
        {
            errorOccured(UserDefine::ID_UNUNIQUE,tr("There are at least two motors with the same ID:%1,\n please check and set suitable!").arg(keys.at(i)));
            break;
        }
    }
}
