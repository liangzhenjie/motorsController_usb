#ifndef MEDIATOR_H
#define MEDIATOR_H
#include <QObject>
#include "motordata.h"
#include "userdefine.h"
#include <functional>
#define TEST_DEBUG
#define LOG_DEBUG
//#define NO_HEART_BEAT
//#define WARNING_DEBUG


const qreal velScale = 6000;
const qreal curScale = 8.25;


#define mediator  Mediator::getInstance()//get instance of Mediator
#define recognizeCallback std::function <void ()>

class Mediator : public QObject
{
    Q_OBJECT
public:
    static Mediator * getInstance();
    static void destroyAllStaticObjects();
    void autoRecognize(recognizeCallback finishedCallback=nullptr,bool bRetry = false);//auto recognize motor

    void SendRequest(const QByteArray & buf);
    //void ClosePort();
    void Handshake(quint32 nDeviceId,bool bSuccess);
    void SetCurParam(const int nDeviceID,const QVariant value, const int nProxyId);//set motor param values
    void SetSucceed(const quint8 nDeviceId,const int nParam);//
    void SetFailed(const int nParam);//设置下位机参数fail
    void revertSwitch(const quint8 nDeviceId);
    //void NullChartPointer();

    void reciveMotorInfo(quint8 communicateUnitId,const quint32 nDeviceMac, const quint8 nDeviceId);
    void receiveNoDataProxy(const int nDeviceID);

    void saveDataToDevice(const quint8 nDeviceId);//download all params to device
    void clearHoming(quint8 nDeviceId);
    void clearHomingSuccessfully(quint8 nDeviceId);
    void setHomingOperation(quint8 nDeviceId,quint8 nId);//switch homing auto or manual

    void playAction(quint32 nMac,MotorData::Motor_Mode mode,qreal value);
    void openChannel(quint8 nDeviceId, const int nChannelId);
    void closeChannel(quint8 nDeviceId, const int nChannelId);
    void setLeftLimit(quint8 nDeviceId);
    void setRightLimit(quint8 nDeviceId);
    void checkServosStatus();//check servos are on or off
	int getConnectStatus()const;
    void recognizeFinished(QMap<quint8,quint32> motorsInfo);
    void setTriggerMode(quint8 nDeviceId,quint8 mode);
    void switchChartData(quint8 nDeviceId,bool bOn);
    void switchCalibrationVel(quint8 nDeviceId,quint8 nValue);
    void switchCalibration(quint8 nDeviceId,quint8 nValue);
    void startCalibration(quint8 nDeviceId);
public slots:
    void response(quint8 nUnitId,const QByteArray buf);
    void reconnectDevice(quint8 nDeviceId);
    void loadDataFromFile();
    void saveDataToFile();
signals:
    void findAvailablePort(int nConnectStatus);
    void clearErrorSuccess(const int nDeviceId);
    void startNewPeriodChart();

    void chartVauleChange(const int nChannelId,qreal values);//only use by chart
    void deviceDataChange(quint8 nDeviceId,MotorData::Motor_Data_Id Id,QVariant value);
    void modeChange(quint8 nDeviceId,MotorData::Motor_Mode mode);
protected:
    Mediator(QObject * parent=0);
private:
    static Mediator *m_pInstance;
    recognizeCallback m_recognizeCallback;
};

#endif // MEDIATOR_H
