#ifndef MOTORDATA_H
#define MOTORDATA_H

#include <QObject>
#include <QMap>
#include <QVector>
#include <QVariant>
#include <QTimer>
#include <QXmlStreamReader>
#include <QFile>
#include <QList>

class MotorData : public QObject
{
    Q_OBJECT

public:
    enum Motor_Mode{
        Mode_None,
        Mode_Cur,
        Mode_Vel,
        Mode_Pos,
        Mode_Teaching,
        Mode_Profile_Pos=6,
        Mode_Profile_Vel,
        Mode_Homing,
    };

    enum Motor_Data_Id{
        CUR_IQ_SET,
        CUR_PROPORTIONAL,
        CUR_INTEGRAL,
        CUR_ID_SET,
        CUR_MINIMAL,
        CUR_MAXIMUM,
        CUR_NOMINAL,
        CUR_OUTPUT,
        CUR_MAXSPEED,
        CUR_ACTURAL,
        CUR_DEMAND,
        VEL_SET,
        VEL_PROPORTIONAL,
        VEL_INTEGRAL,
        VEL_MINIMAL,
        VEL_MAXIMUM,
        VEL_ACTURAL,
        VEL_DEMAND,
        POS_SET,
        POS_PROPORTIONAL,
        POS_INTEGRAL,
        POS_DIFFERENTIAL,
        POS_MINIMAL,
        POS_MAXIMUM,
        POS_STEP_ADD,
        POS_MIN_POS,
        POS_MAX_POS,
        POS_HOMING,
        POS_ACTURAL,
        POS_DEMAND,
        PROFILE_POS_MAX_SPEED,
        PROFILE_POS_ACC,
        PROFILE_POS_DEC,
        PROFILE_VEL_MAX_SPEED,
        PROFILE_VEL_ACC,
        PROFILE_VEL_DEC,
        CHART_FREQUENCY,
        CHART_THRESHOLD,
        POS_OFFSET,
        VOLTAGE,
        HOMING_LIMIT,//if
        HOMING_CUR_MAX,
        HOMING_CUR_MIN,
        CURRENT_SCALE,
        VELOCITY_SCALE,
        FILTER_C_STATUS,
        FILTER_C_VALUE,
        FILTER_V_STATUS,
        FILTER_V_VALUE,
        FILTER_P_STATUS,
        FILTER_P_VALUE,
        INERTIA,
        LOCK_ENERGY,
        TEMP_MOTOR,
        TEMP_INVERTER,
        TEMP_PROTECT,
        TEMP_RECOVERY,
        CALIBRATION_SWITCH,
        CALIBRATION_ANGLE,
        MOTOR_SWITCH,
        MOTOR_VERSION,//
        ONLINE_STATUS,
        DEVICE_ID,
        MAC_ID,
        MODE_ID,
        ERROR_ID,
        DATA_CNT,
        DATA_CHART,//special data,don't need to save
        DATA_INVALID,
    };

    explicit MotorData(const quint8 nDeviceId,const quint32 nDeviceMac,QObject *parent = 0);
    quint8 deviceId() const;
    quint32 deviceMac()const;
    void setValueByProxy(const int nProxyId,QVariant value);//save value that recive
    void requestAllValue();
    QVariant getValue(Motor_Data_Id nDataId)const;
    void setValueByUser(Motor_Data_Id nDataId,QVariant value,bool bSendProxy=true);//set value by user, will send proxy or not
    void responseHeart(bool bSuccess);
    bool isOnline()const;
    void changeDeviceId(quint8 nNewDeviceId);
    void changeDeviceIdSuccessfully();
    QVector<qint16> errorHistory()const{
        return m_errorHistory;
    }
    Motor_Mode currentMode()const;
    ~MotorData();

    qint16 getOldDeviceId()const{
        return m_oldDeviceId;
    }
    bool deviceIdIsAvailable()const;
    void changeDemand(qreal value);//demand value change
    void setRequestActual(bool bRequest){
        m_bRequestActual = bRequest;
    }

protected:
    void setValue(int nDataId,QVariant value,bool bEmitSignal = true);
private:
    void initData();
public slots:
    void activeMode(const int nMode);
    void activeModeSuccessfully();
    void saveData();
    void loadData();
    void reconnect();

private slots:
    void requestActualValue();//request value initiatively
private:
    void saveDataToFile(QString fileName);
    void readDataFromFile(QString fileName);
    void readParams(QXmlStreamReader *reader);
signals:
    void acturalVauleChange(Motor_Mode Id,QVector<qreal> values);//only use by chart
    void currentErrorChange(const int nErrorId);
private:
private:
    qint16 m_oldDeviceId;//old device id,when new device id is available,is -1
    //int m_modeId;
    int m_requestModeId;
    //MotorStatus m_status;

    QVariant m_motorData[DATA_CNT];

    int m_nHeartFailCnt;//
    QTimer * m_pHeartTimer;
    QTimer * m_pValueTimer;
    QVector<qint16> m_errorHistory;

    bool m_bRequestActual;
    //log file
    QFile * m_pFileLog;
};


//motordata manger
#define motorDataMgrInstance MotorDataMgr::getInstance()

class MotorDataMgr : public QObject
{
    Q_OBJECT
public:
    static MotorDataMgr * getInstance();
    virtual ~MotorDataMgr();

    qreal getMotorDataAttrValueAsDouble(const quint8 nDeviceId,const MotorData::Motor_Data_Id attrId)const;
    qint32 getMotorDataAttrValueAsInt(const quint8 nDeviceId,const MotorData::Motor_Data_Id attrId)const;
    void setMotorDataAttr(const quint8 nDeviceId,const MotorData::Motor_Data_Id attrId,QVariant value,bool bSend=true);
    void setMotorDataAttrByProxy(const quint8 nDeviceId,int proxyId,QVariant value);//data from proxy
    void setMotorDataAttrInBatch(const QList<quint8> idList,const MotorData::Motor_Data_Id attrId,QVariant value,bool bSend=true);
    void AddMotorsData(QMap<quint8,quint32> dataMap);
    QMap<quint8,quint32> getMotorsMap()const;
    QVector<qint16> motorErrorHistory(const quint8 nDeviceId)const;
    bool deviceIdHasExist(quint8 nDeviceId);
    void activeMotorMode(const quint8 nDeviceId,const MotorData::Motor_Mode mode);
    void activeMotorModeSuccessfully(const quint8 nDeviceId);
    void activeMotorModeInBatch(const QList<quint8> idList,const MotorData::Motor_Mode mode);
    void changeDeviceIdSuccessfully(const quint8 nDeviceId);
    void regainAllData(const quint8 nDeviceId);
    void regainData(const quint8 nDeviceId,MotorData::Motor_Data_Id attrId);
    void responseHeart(const quint8 nDeviceId,bool bSuccessfully);
    void changDemand(const quint32 nMacId,MotorData::Motor_Mode modeId,qreal value);//
private:
    MotorDataMgr();
signals:
    void dataChanged(const quint8 nDeviceId,const MotorData::Motor_Data_Id attrId,QVariant value);
    void errorOccured(const qint32 erroId,QString errorInfo);
private:
    MotorData * getMotorDataById(const quint8 nId)const;
    MotorData * getMotorDataByMac(const quint32 nMac)const;
    bool checkIdUnique(QMap<quint8,quint32> dataMap)const;//check all motors's id si unique or not, if not warning and exit the app
    void handleUnuiqueError(QMap<quint8,quint32> dataMap);
    QVariant getMotorDataAttrValue(const quint8 nDeviceId,const MotorData::Motor_Data_Id attrId)const;
private:
    QList<MotorData *> m_allMotorDatas;
    static MotorDataMgr * m_pMgr;
};


#endif // MOTORDATA_H
